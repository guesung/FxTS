"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[76],{2604:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>l});var t=s(4848),o=s(8453);const c={id:"to-async"},r="When to use the toAsync function?",i={id:"to-async",title:"When to use the toAsync function?",description:"Many functions in FxTS can handle both Iterable and AsyncIterable. For example, the find function can be used as follows.",source:"@site/docs/to-async.md",sourceDirName:".",slug:"/to-async",permalink:"/docs/to-async",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"to-async"},sidebar:"docs",previous:{title:"Method Chaining",permalink:"/docs/method-chaining"},next:{title:"How to debug in pipeline easily?",permalink:"/docs/how-to-debug"}},a={},l=[];function d(n){const e={code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"when-to-use-the-toasync-function",children:["When to use the ",(0,t.jsx)(e.code,{children:"toAsync"})," function?"]}),"\n",(0,t.jsxs)(e.p,{children:["Many functions in FxTS can handle both ",(0,t.jsx)(e.code,{children:"Iterable"})," and ",(0,t.jsx)(e.code,{children:"AsyncIterable"}),". For example, the ",(0,t.jsx)(e.code,{children:"find"})," function can be used as follows."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"const numbers = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\nconst asyncNumbers = async function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\nfind((num) => num === 2, numbers()); // 2\nfind((num) => num === 2, asyncNumbers()); // Promise<2>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["There is a special point to note. ",(0,t.jsx)(e.code,{children:"AsyncIterable"})," can work fine whether the callback function is running synchronously/asynchronously,\nbut ",(0,t.jsxs)(e.strong,{children:["You can not iterate over ",(0,t.jsx)(e.code,{children:"Iterable"})," using asynchronous callback functions or manipulate types ",(0,t.jsx)(e.code,{children:"Iterable<Promise<T>>"}),"."]})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"const promiseNumbers = function* () {\n  yield Promise.resolve(1);\n  yield Promise.resolve(2);\n  yield Promise.resolve(3);\n};\n\nfind((num) => Promise.resolve(num === 2), numbers()); // not work\nfind((num) => num === 2, promiseNumbers()); // not work\n"})}),"\n",(0,t.jsxs)(e.p,{children:["In order to handle async using FxTS, the value to iterate must be type of ",(0,t.jsx)(e.code,{children:"AsyncIterable"}),".\nIf the callback function is asynchronous or should handle ",(0,t.jsx)(e.code,{children:"Iterable<Promise<T>>"}),", use the ",(0,t.jsx)(e.code,{children:"toAsync"})," function to convert it to ",(0,t.jsx)(e.code,{children:"AsyncIterable"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"await pipe(\n  numbers(), // Iterable<number>\n  toAsync, // AsyncIterable<number>\n  find((num) => Promise.resolve(num === 2)),\n);\n\nawait pipe(\n  promiseNumbers(), // Iterable<Promise<number>>\n  toAsync, // AsyncIterable<number>\n  find((num) => Promise.resolve(num === 2)),\n);\n"})})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>r,x:()=>i});var t=s(6540);const o={},c=t.createContext(o);function r(n){const e=t.useContext(c);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(c.Provider,{value:e},n.children)}}}]);
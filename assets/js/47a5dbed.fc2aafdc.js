"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6087],{1324:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>t,metadata:()=>i,toc:()=>l});var o=e(4848),s=e(8453);const t={id:"error-handling"},a="Error handling",i={id:"error-handling",title:"Error handling",description:"Error handling is an essential part of any programming.",source:"@site/docs/error-handling.md",sourceDirName:".",slug:"/error-handling",permalink:"/docs/error-handling",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"error-handling"},sidebar:"docs",previous:{title:"Handle Concurrency",permalink:"/docs/handle-concurrency"},next:{title:"Method Chaining",permalink:"/docs/method-chaining"}},c={},l=[{value:"Synchronous error handling",id:"synchronous-error-handling",level:3},{value:"Asynchronous error handling",id:"asynchronous-error-handling",level:3},{value:"Concurrency error handling (using Concurrent)",id:"concurrency-error-handling-using-concurrent",level:3}];function h(r){const n={a:"a",code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"error-handling",children:"Error handling"}),"\n",(0,o.jsx)(n.p,{children:"Error handling is an essential part of any programming."}),"\n",(0,o.jsxs)(n.p,{children:["Unlike other libraries, error handling in FxTS does not need to know a specific error handling part.\nSince FxTS follows the protocol of standard, you can easily handle errors with ",(0,o.jsx)(n.code,{children:"try-catch"}),".\nThis means that synchronous/asynchronous error propagation is possible,\nso it is good to use with ",(0,o.jsx)(n.a,{href:"https://sentry.io/",children:"sentry"})," or various 3rd party error logging and debugging tools."]}),"\n",(0,o.jsx)(n.h3,{id:"synchronous-error-handling",children:"Synchronous error handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { map, pipe, take, toArray, toAsync } from "@fxts/core";\n\nconst syncError = (a) => {\n  throw new Error(`err ${a}`);\n};\n\ntry {\n  pipe(\n    [1, 2, 3, 4, 5],\n    map(syncError),\n    filter((a) => a % 2 === 0),\n    toArray,\n  );\n} catch (err) {\n  // handle err\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"asynchronous-error-handling",children:"Asynchronous error handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { filter, map, pipe, toArray, toAsync } from "@fxts/core";\n\nconst fetchAsyncError = (a) => Promise.reject(`err ${a}`);\n\ntry {\n  await pipe(\n    Promise.resolve([1, 2, 3, 4, 5]),\n    toAsync,\n    map(fetchAsyncError),\n    filter((a) => a % 2 === 0),\n    toArray,\n  );\n} catch (err) {\n  // handle err\n}\n\ntry {\n  await pipe(\n    [\n      Promise.resolve(1),\n      Promise.resolve(2),\n      Promise.resolve(3),\n      Promise.resolve(4),\n    ],\n    toAsync,\n    map(fetchAsyncError),\n    filter((a) => a % 2 === 0),\n    toArray,\n  );\n} catch (err) {\n  // handle err\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"concurrency-error-handling-using-concurrent",children:"Concurrency error handling (using Concurrent)"}),"\n",(0,o.jsxs)(n.p,{children:["In the state of concurrent requests, ",(0,o.jsx)(n.code,{children:"AsyncIterable"})," is evaluated as many as the number of ",(0,o.jsx)(n.code,{children:"concurrent"})," requests, even if an error occurred earlier.\nThis is the same case where asynchronous requests are executed with ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all",children:"Promise.all"}),",\n",(0,o.jsx)(n.code,{children:"Promise.all"})," is all executed even if one fails."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { concurrent, filter, map, pipe, toArray, toAsync } from "@fxts/core";\n\nconst fetchAsyncError = (a) => {\n  if (a === 3) {\n    return Promise.reject(`err ${a}`);\n  }\n  return a;\n};\n\ntry {\n  await pipe(\n    [\n      Promise.resolve(1),\n      Promise.resolve(2),\n      Promise.resolve(3), // When this item is evaluated, `map` function throws an error.\n      Promise.resolve(4), // This item is also evaluated.\n      Promise.resolve(5), // Is is not evaluated from this item.\n      Promise.resolve(6),\n    ],\n    toAsync,\n    map(fetchAsyncError),\n    filter((a) => a % 2 === 0),\n    concurrent(2), // request 2\n    toArray,\n  );\n} catch (err) {\n  // handle err\n}\n'})})]})}function d(r={}){const{wrapper:n}={...(0,s.R)(),...r.components};return n?(0,o.jsx)(n,{...r,children:(0,o.jsx)(h,{...r})}):h(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>a,x:()=>i});var o=e(6540);const s={},t=o.createContext(s);function a(r){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof r?r(n):{...n,...r}}),[n,r])}function i(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(s):r.components||s:a(r.components),o.createElement(t.Provider,{value:n},r.children)}}}]);